#include "config.h"
#define MINISKETCH_CAPACITY 160
#include "../routing.c"
#include "../minisketch.c"
#include <common/blinding.h>
#include <common/ecdh.h>
#include <common/json_stream.h>
#include <common/onionreply.h>
#include <common/setup.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for blinding_hash_e_and_ss */
void blinding_hash_e_and_ss(const struct pubkey *e UNNEEDED,
			    const struct secret *ss UNNEEDED,
			    struct sha256 *sha UNNEEDED)
{ fprintf(stderr, "blinding_hash_e_and_ss called!\n"); abort(); }
/* Generated stub for blinding_next_privkey */
bool blinding_next_privkey(const struct privkey *e UNNEEDED,
			   const struct sha256 *h UNNEEDED,
			   struct privkey *next UNNEEDED)
{ fprintf(stderr, "blinding_next_privkey called!\n"); abort(); }
/* Generated stub for blinding_next_pubkey */
bool blinding_next_pubkey(const struct pubkey *pk UNNEEDED,
			  const struct sha256 *h UNNEEDED,
			  struct pubkey *next UNNEEDED)
{ fprintf(stderr, "blinding_next_pubkey called!\n"); abort(); }
/* Generated stub for cupdate_different */
bool cupdate_different(struct gossip_store *gs UNNEEDED,
		       const struct half_chan *hc UNNEEDED,
		       const u8 *cupdate UNNEEDED)
{ fprintf(stderr, "cupdate_different called!\n"); abort(); }
/* Generated stub for ecdh */
void ecdh(const struct pubkey *point UNNEEDED, struct secret *ss UNNEEDED)
{ fprintf(stderr, "ecdh called!\n"); abort(); }
/* Generated stub for gossip_store_add */
u64 gossip_store_add(struct gossip_store *gs UNNEEDED, const u8 *gossip_msg UNNEEDED,
		     u32 timestamp UNNEEDED, bool push UNNEEDED, const u8 *addendum UNNEEDED)
{ fprintf(stderr, "gossip_store_add called!\n"); abort(); }
/* Generated stub for gossip_store_add_private_update */
u64 gossip_store_add_private_update(struct gossip_store *gs UNNEEDED, const u8 *update UNNEEDED)
{ fprintf(stderr, "gossip_store_add_private_update called!\n"); abort(); }
/* Generated stub for gossip_store_get */
const u8 *gossip_store_get(const tal_t *ctx UNNEEDED,
			   struct gossip_store *gs UNNEEDED,
			   u64 offset UNNEEDED)
{ fprintf(stderr, "gossip_store_get called!\n"); abort(); }
/* Generated stub for gossip_store_get_private_update */
const u8 *gossip_store_get_private_update(const tal_t *ctx UNNEEDED,
					  struct gossip_store *gs UNNEEDED,
					  u64 offset UNNEEDED)
{ fprintf(stderr, "gossip_store_get_private_update called!\n"); abort(); }
/* Generated stub for gossip_store_mark_channel_deleted */
void gossip_store_mark_channel_deleted(struct gossip_store *gs UNNEEDED,
				       const struct short_channel_id *scid UNNEEDED)
{ fprintf(stderr, "gossip_store_mark_channel_deleted called!\n"); abort(); }
/* Generated stub for json_add_member */
void json_add_member(struct json_stream *js UNNEEDED,
		     const char *fieldname UNNEEDED,
		     bool quote UNNEEDED,
		     const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "json_add_member called!\n"); abort(); }
/* Generated stub for json_member_direct */
char *json_member_direct(struct json_stream *js UNNEEDED,
			 const char *fieldname UNNEEDED, size_t extra UNNEEDED)
{ fprintf(stderr, "json_member_direct called!\n"); abort(); }
/* Generated stub for json_object_end */
void json_object_end(struct json_stream *js UNNEEDED)
{ fprintf(stderr, "json_object_end called!\n"); abort(); }
/* Generated stub for json_object_start */
void json_object_start(struct json_stream *ks UNNEEDED, const char *fieldname UNNEEDED)
{ fprintf(stderr, "json_object_start called!\n"); abort(); }
/* Generated stub for memleak_add_helper_ */
void memleak_add_helper_(const tal_t *p UNNEEDED, void (*cb)(struct htable *memtable UNNEEDED,
						    const tal_t *)){ }
/* Generated stub for memleak_remove_htable */
void memleak_remove_htable(struct htable *memtable UNNEEDED, const struct htable *ht UNNEEDED)
{ fprintf(stderr, "memleak_remove_htable called!\n"); abort(); }
/* Generated stub for memleak_remove_intmap_ */
void memleak_remove_intmap_(struct htable *memtable UNNEEDED, const struct intmap *m UNNEEDED)
{ fprintf(stderr, "memleak_remove_intmap_ called!\n"); abort(); }
/* Generated stub for nannounce_different */
bool nannounce_different(struct gossip_store *gs UNNEEDED,
			 const struct node *node UNNEEDED,
			 const u8 *nannounce UNNEEDED,
			 bool *only_missing_tlv UNNEEDED)
{ fprintf(stderr, "nannounce_different called!\n"); abort(); }
/* Generated stub for new_onionreply */
struct onionreply *new_onionreply(const tal_t *ctx UNNEEDED, const u8 *contents TAKES UNNEEDED)
{ fprintf(stderr, "new_onionreply called!\n"); abort(); }
/* Generated stub for notleak_ */
void *notleak_(void *ptr UNNEEDED, bool plus_children UNNEEDED)
{ fprintf(stderr, "notleak_ called!\n"); abort(); }
/* Generated stub for peer_supplied_good_gossip */
void peer_supplied_good_gossip(struct peer *peer UNNEEDED, size_t amount UNNEEDED)
{ fprintf(stderr, "peer_supplied_good_gossip called!\n"); abort(); }
/* Generated stub for sanitize_error */
char *sanitize_error(const tal_t *ctx UNNEEDED, const u8 *errmsg UNNEEDED,
		     struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "sanitize_error called!\n"); abort(); }
/* Generated stub for status_failed */
void status_failed(enum status_failreason code UNNEEDED,
		   const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "status_failed called!\n"); abort(); }
/* Generated stub for towire_warningfmt */
u8 *towire_warningfmt(const tal_t *ctx UNNEEDED,
		      const struct channel_id *channel UNNEEDED,
		      const char *fmt UNNEEDED, ...)
{ fprintf(stderr, "towire_warningfmt called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

/* Empty stubs */
struct gossip_store *gossip_store_new(struct routing_state *rstate UNNEEDED,
				      struct list_head *peers UNNEEDED)
{
	return NULL;
}

struct oneshot *new_reltimer_(struct timers *timers UNNEEDED,
			      const tal_t *ctx UNNEEDED,
			      struct timerel expire UNNEEDED,
			      void (*cb)(void *) UNNEEDED, void *arg UNNEEDED)
{
	return NULL;
}

void gossip_store_delete(struct gossip_store *gs UNNEEDED,
			 struct broadcastable *bcast UNNEEDED,
			 int type UNNEEDED)
{
}
void status_fmt(enum log_level level UNNEEDED,
		const struct node_id *peer UNNEEDED,
		const char *fmt UNNEEDED, ...)
{
}

#if EXPERIMENTAL_FEATURES
int main(int argc, char *argv[])
{
	common_setup(argv[0]);
	struct routing_state *rstate;
        rstate = new_routing_state(tmpctx, talz(tmpctx, struct node_id),
				   NULL, NULL, NULL, false, false);
        //init_minisketch(rstate); //handled inside new_routing_state
        struct short_channel_id scid;
	/*Block = 710622 TXindex = 622, Output Index = 0*/
        scid.u64 = 0x0ad7de00026e0000;
	struct chan *chan1;
	chan1 = tal(rstate, struct chan);
	chan1->scid = scid;
	//chan1->minisketch_channel_update[0] = 0;
	//chan1->minisketch_channel_update[1] = 0;
	init_minisketch_channels(chan1);
        u64 sketch_entry;
	if (short_channel_id_blocknum(&scid) != 710622)
		abort();
	assert(minisketch_decode_type(0) == 0);
	assert(minisketch_decode_type(1) == 1);
	assert(minisketch_decode_type(2) == 2);
	/* channel update encoding*/
	u8 cdir = 0;
	sketch_entry = minisketch_encode_cupdate(chan1,cdir,4093);
	assert(sketch_entry == minisketch_encode(1, scid, cdir, 4093));
	assert(minisketch_decode_type(sketch_entry) == 1);
	minisketch_handle_cupdate(rstate,chan1,cdir,4093);
	assert(chan1->minisketch_channel_update[0] != 0);
	/* verify count is correctly updated */
	minisketch_handle_cupdate(rstate,chan1,cdir,4094);
	/*
        printf("scid: 0x%016lX\n",scid.u64);
        printf("sketch encoded: 0x%016lX\n",sketch_entry);
	printf("decoded type: %u\n",minisketch_decode_type(sketch_entry));
	*/
	if ((rstate->sketch_entries != 1) | (rstate->sketch_cupdate_entries != 1))
		abort();
	assert(minisketch_sub_from_sketch(rstate,sketch_entry));
	if ((rstate->sketch_entries != 0) | (rstate->sketch_cupdate_entries != 0))
		abort();
	sketch_entry = minisketch_encode(0, scid, 0, 0xFFFFFFFF);
	minisketch_add_cannounce(rstate,chan1);
	if ((rstate->sketch_entries != 1) | (rstate->sketch_cannounce_entries != 1))
		abort();
	assert(chan1->minisketch_channel_announcement != 0);
	tal_free(chan1);
	//handles destroy_routing_state and destroy_minisketch(rstate) via tal_add_destructor
	common_shutdown();
	return 0;
}
#else
int main(void)
{
	return 0;
}
#endif /* EXPERIMENTAL_FEATURES */
